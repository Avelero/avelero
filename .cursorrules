Code Style and Structure:
- Write concise, technical TypeScript code with accurate examples
- Use functional and declarative programming patterns; avoid classes
- Prefer iteration and modularization over code duplication
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)
- Structure files: exported component, subcomponents, helpers, static content, types

Naming Conventions:
- Use lowercase with dashes for directories (e.g., components/auth-wizard)
- Favor named exports for components

TypeScript Usage:
- Use TypeScript for all code; prefer interfaces over types
- Avoid enums; use maps instead
- Use functional components with TypeScript interfaces

Syntax and Formatting:
- Use the "function" keyword for pure functions
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements
- Use declarative JSX

Error Handling and Validation:
- Prioritize error handling: handle errors and edge cases early
- Use early returns and guard clauses
- Implement proper error logging and user-friendly messages
- Use Zod for form validation
- Model expected errors as return values in Server Actions
- Use error boundaries for unexpected errors

UI and Styling:
- Use Shadcn UI, Radix, and Tailwind Aria for components and styling

Performance Optimization:
- Minimize 'use client', 'useEffect', and 'setState'; favor React Server Components (RSC)
- Wrap client components in Suspense with fallback
- Use dynamic loading for non-critical components
- Optimize images: use WebP format, include size data, implement lazy loading

Key Conventions:
- Use 'nuqs' for URL search parameter state management
- Optimize Web Vitals (LCP, CLS, FID)
- Limit 'use client':
  - Favor server components and Next.js SSR
  - Use only for Web API access in small components
  - Avoid for data fetching or state management

Monorepo Patterns:
- Use workspace imports for internal packages: `import { db } from "@v1/db"`
- Import from specific package exports: `@v1/supabase/server`, `@v1/supabase/client`
- Use absolute imports with `@/` alias for app-internal modules

Server Actions:
- Use `next-safe-action` for all server actions with proper error handling
- Define action metadata with name and optional tracking
- Use `authActionClient` for authenticated actions, `actionClient` for public ones
- Handle errors as return values, not thrown exceptions

API Communication:
- Use tRPC for type-safe API communication between client and server
- Define procedures in `apps/api/src/trpc/routers/`
- Use Hono for API framework with proper CORS and security headers

Database & Data:
- Use Drizzle ORM for all database operations
- Define schemas in `packages/db/src/schema/` with proper foreign keys
- Use Supabase clients: `@v1/supabase/server` for server-side, `@v1/supabase/client` for client-side
- Validate environment variables with `@t3-oss/env-nextjs`

Code Quality:
- Format and lint with Biome: `bun run format` and `bun run lint`
- Use TypeScript strict mode with centralized tsconfig from `packages/tsconfig/`
- Follow Turborepo conventions for build dependencies and caching

Follow Next.js docs for Data Fetching, Rendering, and Routing
