# Barcode Coverage Feature Specification

## Executive Summary

This specification defines the implementation of barcode coverage tracking for Digital Product Passports (DPPs). The feature enforces brand-level barcode uniqueness, validates barcode format (GS1 GTIN standards), provides real-time uniqueness checking in the UI, and displays barcode completion status in the passports table.

---

## 1. Background & Context

### 1.1 GS1 Digital Link URLs

Digital Product Passports can be accessed via three URL patterns:
1. **Native Avelero**: `passport.avelero.com/{upid}` (always functional)
2. **Custom Domain + UPID**: `passport.nike.com/{upid}` (always functional)
3. **GS1 Digital Link**: `passport.nike.com/01/{GTIN}` (requires unique barcode)

The GS1 Digital Link format requires globally unique barcodes within a brand to resolve correctly.

### 1.2 GS1 GTIN Standards

Valid GTIN formats:
| Format   | Digits | Primary Use                        |
|----------|--------|------------------------------------|
| GTIN-8   | 8      | Small items (e.g., chewing gum)    |
| GTIN-12  | 12     | UPC - primarily North America      |
| GTIN-13  | 13     | EAN - Europe and rest of world     |
| GTIN-14  | 14     | Cases and wholesale packaging      |

**Validation rule**: Barcodes must be exactly 8, 12, 13, or 14 digits (numeric only).

### 1.3 Core Decisions

1. **Barcodes are optional** - Not required for passport creation
2. **Brand-level uniqueness** - Same barcode can exist in different brands (not global)
3. **Hard enforcement** - Duplicate barcodes are blocked, not just warned
4. **Three-layer validation** - Database constraint + API validation + Client-side check

---

## 2. Database Schema Changes

### 2.1 Schema Modification

**File**: `packages/db/src/schema/products/product-variants.ts`

Add a unique constraint on barcode scoped to brand:

```typescript
// Add to table definition indexes/constraints
uniqueIndex("idx_unique_barcode_per_brand")
  .on(table.barcode, sql`get_product_brand_id(product_id)`)
  .where(sql`barcode IS NOT NULL AND barcode != ''`),
```

### 2.2 Migration

**File**: `packages/db/drizzle/migrations/XXXX_add_barcode_uniqueness.sql` (auto-generated by `bun db:generate`)

The migration will:
1. Check for existing duplicate barcodes within brands
2. Add the unique index constraint

**Pre-migration validation**: Before applying the migration, run a query to identify duplicate barcodes:
```sql
SELECT pv.barcode, p.brand_id, COUNT(*) as count
FROM product_variants pv
JOIN products p ON p.id = pv.product_id
WHERE pv.barcode IS NOT NULL AND pv.barcode != ''
GROUP BY pv.barcode, p.brand_id
HAVING COUNT(*) > 1;
```

If duplicates exist, they must be resolved before migration can proceed.

---

## 3. API Layer Changes

### 3.1 New Endpoint: Check Barcode Uniqueness

**File**: `apps/api/src/trpc/routers/products/variants.ts`

Add a new query procedure following the `brand.checkSlug` pattern:

```typescript
checkBarcode: brandRequiredProcedure
  .input(z.object({
    barcode: z.string().min(1),
    excludeVariantId: z.string().uuid().optional() // For updates
  }))
  .query(async ({ ctx, input }) => {
    const { db, brandId } = ctx;
    const taken = await isBarcodesTakenInBrand(db, brandId, input.barcode, input.excludeVariantId);
    return { available: !taken };
  });
```

### 3.2 New Database Query Function

**File**: `packages/db/src/queries/products/variants.ts`

```typescript
/**
 * Checks if a barcode is already taken within a brand.
 *
 * @param db - Database instance
 * @param brandId - The brand ID to check within
 * @param barcode - The barcode to check
 * @param excludeVariantId - Optional variant ID to exclude (for updates)
 * @returns true if barcode is taken, false if available
 */
export async function isBarcodeTakenInBrand(
  db: Database,
  brandId: string,
  barcode: string,
  excludeVariantId?: string,
): Promise<boolean> {
  const conditions = [
    eq(productVariants.barcode, barcode),
    eq(products.brandId, brandId),
  ];

  if (excludeVariantId) {
    conditions.push(ne(productVariants.id, excludeVariantId));
  }

  const rows = await db
    .select({ id: productVariants.id })
    .from(productVariants)
    .innerJoin(products, eq(products.id, productVariants.productId))
    .where(and(...conditions))
    .limit(1);

  return rows.length > 0;
}
```

### 3.3 Barcode Format Validation Schema

**File**: `apps/api/src/schemas/products.ts` (or `_shared/primitives.ts`)

```typescript
/**
 * GS1 GTIN barcode validation schema.
 * Accepts 8, 12, 13, or 14 digit numeric strings.
 * Does NOT validate check digits (brands may have legacy data with invalid checksums).
 */
export const barcodeSchema = z
  .string()
  .regex(
    /^(\d{8}|\d{12}|\d{13}|\d{14})$/,
    "Barcode must be exactly 8, 12, 13, or 14 digits"
  )
  .optional();

/**
 * Validates barcode format without making it required.
 * Returns undefined for empty/whitespace strings.
 */
export function normalizeBarcode(value: string | null | undefined): string | undefined {
  if (!value) return undefined;
  const trimmed = value.trim();
  if (!trimmed) return undefined;
  return trimmed;
}
```

### 3.4 Update Variant Schemas

**File**: `apps/api/src/trpc/routers/products/variants.ts`

Update the existing schemas:

```typescript
const createVariantInputSchema = z.object({
  attributeValueIds: z.array(z.string().uuid()).optional().default([]),
  sku: z.string().max(100).optional(),
  barcode: barcodeSchema, // Updated: use barcode validation schema
  overrides: variantOverridesSchema,
});

const updateVariantInputSchema = z.object({
  variantUpid: z.string().min(1),
  attributeValueIds: z.array(z.string().uuid()).optional(),
  sku: z.string().max(100).optional(),
  barcode: barcodeSchema, // Updated: use barcode validation schema
  overrides: variantOverridesSchema,
});

const syncVariantInputSchema = z.object({
  upid: z.string().optional(),
  attributeValueIds: z.array(z.string().uuid()).optional().default([]),
  sku: z.string().max(100).optional(),
  barcode: barcodeSchema, // Updated: use barcode validation schema
  isGhost: z.boolean().optional(),
});
```

### 3.5 Update Variant Create/Update Mutations

Add barcode uniqueness validation before insert/update:

**In variant create mutation:**
```typescript
// Before inserting variant
if (input.barcode) {
  const barcodeTaken = await isBarcodeTakenInBrand(ctx.db, brandId, input.barcode);
  if (barcodeTaken) {
    throw badRequest("This barcode is already used by another variant in your brand");
  }
}
```

**In variant update mutation:**
```typescript
// Before updating variant
if (input.barcode !== undefined && input.barcode !== null) {
  const barcodeTaken = await isBarcodeTakenInBrand(
    ctx.db,
    brandId,
    input.barcode,
    variantId // Exclude current variant
  );
  if (barcodeTaken) {
    throw badRequest("This barcode is already used by another variant in your brand");
  }
}
```

**In variant sync mutation:**
```typescript
// During sync, validate all barcodes in the batch
const barcodesToCheck = variants
  .filter(v => v.barcode && !v.upid) // New variants with barcodes
  .map(v => v.barcode!);

if (barcodesToCheck.length > 0) {
  const takenBarcodes = await getBatchTakenBarcodes(ctx.db, brandId, barcodesToCheck);
  if (takenBarcodes.length > 0) {
    throw badRequest(`The following barcodes are already in use: ${takenBarcodes.join(', ')}`);
  }
}
```

---

## 4. Client-Side Changes

### 4.1 Real-Time Barcode Uniqueness Check Component

**File**: `apps/app/src/components/tables/variants/variant-row.tsx`

Update the barcode input field to include a uniqueness check spinner, following the pattern from `set-slug.tsx`:

```typescript
interface VariantRowProps {
  // ... existing props
  /** Current variant ID (for excluding from uniqueness check on updates) */
  variantId?: string;
  /** Whether this variant has been saved (has a UPID) */
  isSaved: boolean;
}

export function VariantRow({
  // ... existing props
  variantId,
  isSaved,
}: VariantRowProps) {
  const trpc = useTRPC();
  const [localBarcode, setLocalBarcode] = useState(barcode);

  // Debounce barcode for availability check
  const debouncedBarcode = useDebounce(localBarcode.trim(), 500);

  // Barcode format validation
  const isFormatValid = !localBarcode.trim() || /^(\d{8}|\d{12}|\d{13}|\d{14})$/.test(localBarcode.trim());
  const isEmpty = !localBarcode.trim();
  const isDirty = localBarcode.trim() !== barcode.trim();

  // Check barcode availability using tRPC query
  const barcodeCheckQuery = useQuery({
    ...trpc.products.variants.checkBarcode.queryOptions({
      barcode: debouncedBarcode,
      excludeVariantId: isSaved ? variantId : undefined,
    }),
    enabled: Boolean(
      debouncedBarcode &&
      isFormatValid &&
      isDirty &&
      debouncedBarcode.length >= 8
    ),
    staleTime: 10000,
  });

  const isChecking = barcodeCheckQuery.isLoading ||
    (localBarcode.trim() !== debouncedBarcode && isDirty && !isEmpty && isFormatValid);

  const isAvailable = barcodeCheckQuery.data?.available ?? null;
  const isTaken = isAvailable === false;
  const showStatus = !isEmpty && isFormatValid && isDirty &&
    debouncedBarcode === localBarcode.trim() && !isChecking;

  return (
    // ... existing JSX
    <div className="border-l border-border relative" onClick={(e) => e.stopPropagation()}>
      <Input
        value={localBarcode}
        onChange={(e) => {
          setLocalBarcode(e.target.value);
          onBarcodeChange(e.target.value);
        }}
        placeholder="Barcode"
        className={cn(
          "h-full w-full rounded-none border-0 bg-transparent type-p px-4 pr-10 focus-visible:ring-[1.5px] focus-visible:ring-brand",
          !isFormatValid && "text-destructive",
          isTaken && showStatus && "text-destructive",
        )}
      />
      {/* Loading spinner */}
      {isChecking && (
        <div className="absolute right-3 top-1/2 -translate-y-1/2">
          <Icons.Loader2 className="h-4 w-4 animate-spin text-secondary" />
        </div>
      )}
      {/* Error indicator */}
      {showStatus && isTaken && (
        <Tooltip>
          <TooltipTrigger asChild>
            <div className="absolute right-3 top-1/2 -translate-y-1/2">
              <Icons.AlertCircle className="h-4 w-4 text-destructive" />
            </div>
          </TooltipTrigger>
          <TooltipContent>Barcode already in use</TooltipContent>
        </Tooltip>
      )}
      {/* Format error indicator */}
      {!isEmpty && !isFormatValid && (
        <Tooltip>
          <TooltipTrigger asChild>
            <div className="absolute right-3 top-1/2 -translate-y-1/2">
              <Icons.AlertCircle className="h-4 w-4 text-destructive" />
            </div>
          </TooltipTrigger>
          <TooltipContent>Must be 8, 12, 13, or 14 digits</TooltipContent>
        </Tooltip>
      )}
    </div>
  );
}
```

### 4.2 Passports Table Barcode Column

**File**: `apps/app/src/components/tables/passports/columns.tsx`

Add a new column for barcode coverage:

```typescript
// Barcode coverage column
{
  id: "barcodeCoverage",
  header: "Barcodes",
  cell: ({ row }) => {
    const variantsWithBarcode = row.original.variantsWithBarcode ?? 0;
    const totalVariants = row.original.variantCount ?? 0;
    const percentage = totalVariants > 0 ? (variantsWithBarcode / totalVariants) * 100 : 0;
    const isComplete = variantsWithBarcode === totalVariants && totalVariants > 0;

    return (
      <div className="flex items-center gap-1.5">
        {/* Count text */}
        <span className="type-p text-secondary whitespace-nowrap">
          {variantsWithBarcode} / {totalVariants}
        </span>
        {/* Progress bar */}
        <div className="flex-1 h-1.5 bg-border rounded-full overflow-hidden min-w-[60px]">
          <div
            className="h-full bg-brand rounded-full transition-all"
            style={{ width: `${percentage}%` }}
          />
        </div>
      </div>
    );
  },
  meta: {
    headerClassName: cn("w-[140px] min-w-[140px] max-w-[140px]"),
    cellClassName: cn("w-[140px] min-w-[140px] max-w-[140px]"),
  },
},
```

### 4.3 Passports Table Types Update

**File**: `apps/app/src/components/tables/passports/types.ts`

```typescript
export interface PassportTableRow extends ProductPassportRow {
  passportIds: string[];
  variantCount: number;
  variantsWithBarcode: number; // NEW: count of variants with non-empty barcode
  tags: Array<{ id: string; name: string | null; hex: string | null }>;
  firstVariantUpid?: string | null;
}
```

### 4.4 Quick Filter: Barcode Complete

**File**: `apps/app/src/config/filters.ts`

Add barcode complete filter to Tier 1:

```typescript
barcodeComplete: {
  id: "barcodeComplete",
  label: "Barcode complete",
  tier: 1,
  category: "metadata",
  inputType: "multi-select",
  operators: [...OPERATORS.multiSelect] as FilterOperator[],
  options: [
    { value: "complete", label: "Complete" },
    { value: "incomplete", label: "Incomplete" },
    { value: "none", label: "No barcodes" },
  ],
  description: "Filter by barcode completion status",
},
```

Update `FIELD_CATEGORIES.metadata.fields`:
```typescript
metadata: {
  label: "Metadata",
  fields: ["status", "tagId", "barcodeComplete", "createdAt", "updatedAt"],
},
```

### 4.5 Advanced Filter: Barcode Coverage

**File**: `apps/app/src/config/filters.ts`

Add advanced barcode filter (Tier 2):

```typescript
barcodeCoveragePercent: {
  id: "barcodeCoveragePercent",
  label: "Barcode coverage %",
  tier: 2,
  category: "metadata",
  inputType: "number",
  operators: [...OPERATORS.number] as FilterOperator[],
  unit: "%",
  placeholder: "0-100",
  description: "Filter by percentage of variants with barcodes",
},
```

---

## 5. Database Query Layer Updates

### 5.1 Product List Query Enhancement

**File**: `packages/db/src/queries/products/list.ts`

Update `listProductsWithIncludes` to include barcode count:

```typescript
// In the variant count subquery, add barcode count
const variantsWithBarcodeSubquery = db
  .select({
    productId: productVariants.productId,
    count: sql<number>`COUNT(CASE WHEN barcode IS NOT NULL AND barcode != '' THEN 1 END)::int`.as('variants_with_barcode'),
  })
  .from(productVariants)
  .where(eq(productVariants.isGhost, false))
  .groupBy(productVariants.productId)
  .as('variants_with_barcode');
```

### 5.2 Filter Conversion for Barcode Complete

**File**: `packages/db/src/queries/products/filter-to-sql.ts` (or wherever filters are converted)

Add handling for `barcodeComplete` filter:

```typescript
case 'barcodeComplete': {
  // This requires a subquery to compare variant barcode counts
  const values = condition.value as string[];
  const conditions: SQL[] = [];

  if (values.includes('complete')) {
    // All variants have barcodes
    conditions.push(sql`(
      SELECT COUNT(*) FROM product_variants pv
      WHERE pv.product_id = products.id AND pv.is_ghost = false
    ) = (
      SELECT COUNT(*) FROM product_variants pv
      WHERE pv.product_id = products.id AND pv.is_ghost = false
      AND pv.barcode IS NOT NULL AND pv.barcode != ''
    ) AND (
      SELECT COUNT(*) FROM product_variants pv
      WHERE pv.product_id = products.id AND pv.is_ghost = false
    ) > 0`);
  }

  if (values.includes('incomplete')) {
    // Some but not all variants have barcodes
    conditions.push(sql`(
      SELECT COUNT(*) FROM product_variants pv
      WHERE pv.product_id = products.id AND pv.is_ghost = false
      AND pv.barcode IS NOT NULL AND pv.barcode != ''
    ) > 0 AND (
      SELECT COUNT(*) FROM product_variants pv
      WHERE pv.product_id = products.id AND pv.is_ghost = false
      AND pv.barcode IS NOT NULL AND pv.barcode != ''
    ) < (
      SELECT COUNT(*) FROM product_variants pv
      WHERE pv.product_id = products.id AND pv.is_ghost = false
    )`);
  }

  if (values.includes('none')) {
    // No variants have barcodes
    conditions.push(sql`(
      SELECT COUNT(*) FROM product_variants pv
      WHERE pv.product_id = products.id AND pv.is_ghost = false
      AND pv.barcode IS NOT NULL AND pv.barcode != ''
    ) = 0`);
  }

  return or(...conditions);
}
```

---

## 6. Bulk Import Handling

### 6.1 Barcode Validation During Import

**File**: `packages/jobs/src/import/processor.ts` (or relevant import processor)

During bulk import:
1. **Format validation**: Skip barcodes that don't match GTIN format
2. **Uniqueness check**: Skip duplicate barcodes (within import + existing in DB)
3. **Report**: Include skipped barcodes in import summary

```typescript
// During row processing
function validateBarcode(barcode: string | null | undefined, existingBarcodes: Set<string>): {
  valid: boolean;
  normalized: string | null;
  error?: string;
} {
  if (!barcode || !barcode.trim()) {
    return { valid: true, normalized: null };
  }

  const normalized = barcode.trim();

  // Format check
  if (!/^(\d{8}|\d{12}|\d{13}|\d{14})$/.test(normalized)) {
    return {
      valid: false,
      normalized: null,
      error: `Invalid barcode format: "${normalized}" (must be 8, 12, 13, or 14 digits)`
    };
  }

  // Uniqueness check within import batch
  if (existingBarcodes.has(normalized)) {
    return {
      valid: false,
      normalized: null,
      error: `Duplicate barcode in import: "${normalized}"`
    };
  }

  return { valid: true, normalized };
}
```

### 6.2 Import Summary Enhancement

Include barcode statistics in import results:
```typescript
interface ImportSummary {
  // ... existing fields
  barcodeStats: {
    total: number;           // Total rows with barcode values
    valid: number;           // Successfully imported
    invalidFormat: number;   // Skipped due to format
    duplicate: number;       // Skipped due to duplicates
  };
}
```

---

## 7. File Tree Overview

### 7.1 Files to Create

| File | Description |
|------|-------------|
| `packages/db/__tests__/unit/queries/barcode-uniqueness.test.ts` | Unit tests for barcode uniqueness queries |
| `apps/api/__tests__/integration/trpc/barcode-validation.test.ts` | Integration tests for barcode API endpoints |
| `apps/api/__tests__/unit/schemas/barcode.test.ts` | Unit tests for barcode schema validation |

### 7.2 Files to Modify

| File | Changes |
|------|---------|
| `packages/db/src/schema/products/product-variants.ts` | Add unique index constraint |
| `packages/db/src/queries/products/variants.ts` | Add `isBarcodeTakenInBrand()` function |
| `packages/db/src/queries/products/list.ts` | Add `variantsWithBarcode` count |
| `apps/api/src/trpc/routers/products/variants.ts` | Add `checkBarcode` endpoint, validation in mutations |
| `apps/api/src/schemas/products.ts` | Add `barcodeSchema` |
| `apps/app/src/components/tables/variants/variant-row.tsx` | Add uniqueness check spinner |
| `apps/app/src/components/tables/passports/columns.tsx` | Add barcode coverage column |
| `apps/app/src/components/tables/passports/types.ts` | Add `variantsWithBarcode` field |
| `apps/app/src/config/filters.ts` | Add `barcodeComplete` filter |

### 7.3 Files to Delete

None.

---

## 8. Behavior Specifications

### 8.1 Barcode Format Validation

| Input | Valid | Reason |
|-------|-------|--------|
| `"12345678"` | Yes | 8 digits (GTIN-8) |
| `"123456789012"` | Yes | 12 digits (GTIN-12/UPC) |
| `"1234567890123"` | Yes | 13 digits (GTIN-13/EAN) |
| `"12345678901234"` | Yes | 14 digits (GTIN-14) |
| `"1234567"` | No | 7 digits (invalid) |
| `"123456789"` | No | 9 digits (invalid) |
| `"12345678901234567"` | No | 17 digits (too long) |
| `"ABC12345678"` | No | Contains letters |
| `"1234-5678-9012"` | No | Contains dashes |
| `"  12345678  "` | Yes | Whitespace trimmed |
| `""` | Yes | Empty is allowed (barcode optional) |
| `null` | Yes | Null is allowed |

### 8.2 Uniqueness Rules

| Scenario | Allowed |
|----------|---------|
| Same barcode in different brands | Yes |
| Same barcode in same brand, different products | No |
| Same barcode in same product, different variants | No |
| Updating variant to keep its own barcode | Yes |
| Updating variant to another variant's barcode | No |
| Empty/null barcode (multiple variants) | Yes |

### 8.3 Error Messages

| Scenario | Error Message |
|----------|---------------|
| Invalid format | "Barcode must be exactly 8, 12, 13, or 14 digits" |
| Duplicate in brand | "This barcode is already used by another variant in your brand" |
| Duplicate in bulk import | "Duplicate barcode in import: {barcode}" |

### 8.4 UI States

**Barcode Input Field States:**

| State | Visual Indicator |
|-------|------------------|
| Empty | Normal input |
| Typing (debouncing) | No indicator |
| Checking uniqueness | Spinner on right |
| Available | No indicator (green checkmark optional) |
| Taken | Red alert icon with tooltip |
| Invalid format | Red alert icon with tooltip |

**Passports Table Barcode Column:**

| Coverage | Display |
|----------|---------|
| 6/6 | "6 / 6" + full blue progress bar |
| 4/6 | "4 / 6" + 66% blue progress bar |
| 0/6 | "0 / 6" + empty (gray) progress bar |
| 0/0 | "0 / 0" + empty progress bar |

---

## 9. Test Cases

### 9.1 Unit Tests: Barcode Schema Validation

**File**: `apps/api/__tests__/unit/schemas/barcode.test.ts`

```typescript
describe("barcodeSchema", () => {
  // Valid formats
  test("accepts 8-digit GTIN-8", () => {
    expect(() => barcodeSchema.parse("12345678")).not.toThrow();
  });

  test("accepts 12-digit GTIN-12/UPC", () => {
    expect(() => barcodeSchema.parse("123456789012")).not.toThrow();
  });

  test("accepts 13-digit GTIN-13/EAN", () => {
    expect(() => barcodeSchema.parse("1234567890123")).not.toThrow();
  });

  test("accepts 14-digit GTIN-14", () => {
    expect(() => barcodeSchema.parse("12345678901234")).not.toThrow();
  });

  test("accepts undefined (optional)", () => {
    expect(() => barcodeSchema.parse(undefined)).not.toThrow();
  });

  // Invalid formats
  test("rejects 7-digit string", () => {
    expect(() => barcodeSchema.parse("1234567")).toThrow();
  });

  test("rejects 9-digit string", () => {
    expect(() => barcodeSchema.parse("123456789")).toThrow();
  });

  test("rejects 10-digit string", () => {
    expect(() => barcodeSchema.parse("1234567890")).toThrow();
  });

  test("rejects 11-digit string", () => {
    expect(() => barcodeSchema.parse("12345678901")).toThrow();
  });

  test("rejects 15-digit string", () => {
    expect(() => barcodeSchema.parse("123456789012345")).toThrow();
  });

  test("rejects alphanumeric string", () => {
    expect(() => barcodeSchema.parse("ABC12345678")).toThrow();
  });

  test("rejects string with dashes", () => {
    expect(() => barcodeSchema.parse("1234-5678-9012")).toThrow();
  });

  test("rejects string with spaces", () => {
    expect(() => barcodeSchema.parse("1234 5678 9012")).toThrow();
  });
});

describe("normalizeBarcode", () => {
  test("trims whitespace from valid barcode", () => {
    expect(normalizeBarcode("  12345678  ")).toBe("12345678");
  });

  test("returns undefined for empty string", () => {
    expect(normalizeBarcode("")).toBeUndefined();
  });

  test("returns undefined for whitespace-only string", () => {
    expect(normalizeBarcode("   ")).toBeUndefined();
  });

  test("returns undefined for null", () => {
    expect(normalizeBarcode(null)).toBeUndefined();
  });

  test("returns undefined for undefined", () => {
    expect(normalizeBarcode(undefined)).toBeUndefined();
  });

  test("preserves valid barcode", () => {
    expect(normalizeBarcode("1234567890123")).toBe("1234567890123");
  });
});
```

### 9.2 Unit Tests: Barcode Uniqueness Query

**File**: `packages/db/__tests__/unit/queries/barcode-uniqueness.test.ts`

```typescript
describe("isBarcodeTakenInBrand", () => {
  let testDb: Database;
  let brandId: string;
  let productId: string;
  let variantId: string;

  beforeEach(async () => {
    // Setup test data
    const brand = await createTestBrand("Test Brand");
    brandId = brand.id;
    // Create product and variant with barcode
    productId = await createTestProduct(brandId, { name: "Test Product" });
    variantId = await createTestVariant(productId, { barcode: "1234567890123" });
  });

  afterEach(async () => {
    await cleanupTables();
  });

  test("returns true when barcode exists in brand", async () => {
    const result = await isBarcodeTakenInBrand(testDb, brandId, "1234567890123");
    expect(result).toBe(true);
  });

  test("returns false when barcode does not exist in brand", async () => {
    const result = await isBarcodeTakenInBrand(testDb, brandId, "9999999999999");
    expect(result).toBe(false);
  });

  test("returns false when checking same variant (excludeVariantId)", async () => {
    const result = await isBarcodeTakenInBrand(
      testDb,
      brandId,
      "1234567890123",
      variantId
    );
    expect(result).toBe(false);
  });

  test("returns true when another variant has same barcode (excludeVariantId)", async () => {
    // Create another variant
    const otherVariantId = await createTestVariant(productId, { barcode: "9876543210987" });

    const result = await isBarcodeTakenInBrand(
      testDb,
      brandId,
      "1234567890123",
      otherVariantId // Excluding different variant
    );
    expect(result).toBe(true);
  });

  test("returns false for barcode in different brand", async () => {
    // Create different brand
    const otherBrand = await createTestBrand("Other Brand");

    const result = await isBarcodeTakenInBrand(otherBrand.id, "1234567890123");
    expect(result).toBe(false);
  });

  test("returns false for empty barcode", async () => {
    const result = await isBarcodeTakenInBrand(testDb, brandId, "");
    expect(result).toBe(false);
  });

  test("handles case sensitivity (barcodes are case-insensitive numbers)", async () => {
    // Barcodes should be numeric, but test defensive handling
    const result = await isBarcodeTakenInBrand(testDb, brandId, "1234567890123");
    expect(result).toBe(true);
  });
});
```

### 9.3 Integration Tests: Barcode Check Endpoint

**File**: `apps/api/__tests__/integration/trpc/barcode-validation.test.ts`

```typescript
import "../../setup";
import { describe, expect, it, beforeEach, afterEach } from "bun:test";
import { cleanupTables, createTestBrand, createTestUser, testDb } from "@v1/db/testing";
import { productVariantsRouter } from "../../../src/trpc/routers/products/variants";

describe("products.variants.checkBarcode", () => {
  let brandId: string;
  let userId: string;
  let productId: string;
  let existingVariantId: string;

  beforeEach(async () => {
    const user = await createTestUser("test@example.com");
    userId = user.id;
    const brand = await createTestBrand("Test Brand", userId);
    brandId = brand.id;
    productId = await createTestProduct(brandId);
    existingVariantId = await createTestVariant(productId, { barcode: "1234567890123" });
  });

  afterEach(async () => {
    await cleanupTables();
  });

  describe("availability check", () => {
    it("returns available: true for unused barcode", async () => {
      const ctx = createMockContext({ brandId, userId });
      const result = await productVariantsRouter.createCaller(ctx).checkBarcode({
        barcode: "9999999999999",
      });
      expect(result.available).toBe(true);
    });

    it("returns available: false for existing barcode", async () => {
      const ctx = createMockContext({ brandId, userId });
      const result = await productVariantsRouter.createCaller(ctx).checkBarcode({
        barcode: "1234567890123",
      });
      expect(result.available).toBe(false);
    });

    it("returns available: true when excluding own variant", async () => {
      const ctx = createMockContext({ brandId, userId });
      const result = await productVariantsRouter.createCaller(ctx).checkBarcode({
        barcode: "1234567890123",
        excludeVariantId: existingVariantId,
      });
      expect(result.available).toBe(true);
    });

    it("returns available: true for barcode in different brand", async () => {
      // Create another brand with same barcode
      const otherBrand = await createTestBrand("Other Brand", userId);
      const otherProduct = await createTestProduct(otherBrand.id);
      await createTestVariant(otherProduct, { barcode: "5555555555555" });

      const ctx = createMockContext({ brandId, userId }); // Original brand context
      const result = await productVariantsRouter.createCaller(ctx).checkBarcode({
        barcode: "5555555555555",
      });
      expect(result.available).toBe(true);
    });
  });

  describe("input validation", () => {
    it("requires non-empty barcode", async () => {
      const ctx = createMockContext({ brandId, userId });
      await expect(
        productVariantsRouter.createCaller(ctx).checkBarcode({ barcode: "" })
      ).rejects.toThrow();
    });

    it("accepts valid excludeVariantId UUID", async () => {
      const ctx = createMockContext({ brandId, userId });
      const result = await productVariantsRouter.createCaller(ctx).checkBarcode({
        barcode: "1234567890123",
        excludeVariantId: existingVariantId,
      });
      expect(result).toBeDefined();
    });

    it("rejects invalid excludeVariantId", async () => {
      const ctx = createMockContext({ brandId, userId });
      await expect(
        productVariantsRouter.createCaller(ctx).checkBarcode({
          barcode: "1234567890123",
          excludeVariantId: "not-a-uuid",
        })
      ).rejects.toThrow();
    });
  });
});
```

### 9.4 Integration Tests: Variant Create with Barcode

**File**: `apps/api/__tests__/integration/trpc/barcode-validation.test.ts` (continued)

```typescript
describe("products.variants.create with barcode", () => {
  // ... setup ...

  describe("barcode validation on create", () => {
    it("creates variant with valid unique barcode", async () => {
      const ctx = createMockContext({ brandId, userId });
      const result = await productVariantsRouter.createCaller(ctx).create({
        productHandle: "test-product",
        barcode: "8888888888888",
        attributeValueIds: [],
      });
      expect(result.barcode).toBe("8888888888888");
    });

    it("rejects duplicate barcode in same brand", async () => {
      const ctx = createMockContext({ brandId, userId });
      await expect(
        productVariantsRouter.createCaller(ctx).create({
          productHandle: "test-product",
          barcode: "1234567890123", // Already exists
          attributeValueIds: [],
        })
      ).rejects.toThrow("already used by another variant");
    });

    it("allows variant creation without barcode", async () => {
      const ctx = createMockContext({ brandId, userId });
      const result = await productVariantsRouter.createCaller(ctx).create({
        productHandle: "test-product",
        attributeValueIds: [],
      });
      expect(result.barcode).toBeNull();
    });

    it("rejects invalid barcode format", async () => {
      const ctx = createMockContext({ brandId, userId });
      await expect(
        productVariantsRouter.createCaller(ctx).create({
          productHandle: "test-product",
          barcode: "ABC123", // Invalid format
          attributeValueIds: [],
        })
      ).rejects.toThrow("8, 12, 13, or 14 digits");
    });

    it("allows same barcode in different brand", async () => {
      // Create different brand context
      const otherBrand = await createTestBrand("Other Brand", userId);
      await createTestProduct(otherBrand.id, { productHandle: "other-product" });

      const ctx = createMockContext({ brandId: otherBrand.id, userId });
      const result = await productVariantsRouter.createCaller(ctx).create({
        productHandle: "other-product",
        barcode: "1234567890123", // Same as original brand
        attributeValueIds: [],
      });
      expect(result.barcode).toBe("1234567890123");
    });
  });
});
```

### 9.5 Integration Tests: Variant Update with Barcode

```typescript
describe("products.variants.update with barcode", () => {
  // ... setup with existing variant ...

  describe("barcode validation on update", () => {
    it("updates variant with new unique barcode", async () => {
      const ctx = createMockContext({ brandId, userId });
      const result = await productVariantsRouter.createCaller(ctx).update({
        productHandle: "test-product",
        variantUpid: existingUpid,
        barcode: "7777777777777",
      });
      expect(result.barcode).toBe("7777777777777");
    });

    it("allows keeping same barcode", async () => {
      const ctx = createMockContext({ brandId, userId });
      const result = await productVariantsRouter.createCaller(ctx).update({
        productHandle: "test-product",
        variantUpid: existingUpid,
        barcode: "1234567890123", // Keep existing
      });
      expect(result.barcode).toBe("1234567890123");
    });

    it("rejects changing to another variant's barcode", async () => {
      // Create another variant with different barcode
      const otherVariant = await createTestVariant(productId, { barcode: "5555555555555" });

      const ctx = createMockContext({ brandId, userId });
      await expect(
        productVariantsRouter.createCaller(ctx).update({
          productHandle: "test-product",
          variantUpid: existingUpid,
          barcode: "5555555555555", // Another variant's barcode
        })
      ).rejects.toThrow("already used by another variant");
    });

    it("allows clearing barcode (set to null/undefined)", async () => {
      const ctx = createMockContext({ brandId, userId });
      const result = await productVariantsRouter.createCaller(ctx).update({
        productHandle: "test-product",
        variantUpid: existingUpid,
        barcode: undefined,
      });
      // Barcode should be cleared or unchanged based on implementation
      // This tests that undefined doesn't throw
      expect(result).toBeDefined();
    });
  });
});
```

### 9.6 Integration Tests: Variant Sync with Barcodes

```typescript
describe("products.variants.sync with barcodes", () => {
  // ... setup ...

  describe("barcode handling in sync", () => {
    it("creates new variants with unique barcodes", async () => {
      const ctx = createMockContext({ brandId, userId });
      const result = await productVariantsRouter.createCaller(ctx).sync({
        productHandle: "test-product",
        variants: [
          { attributeValueIds: [], barcode: "1111111111111" },
          { attributeValueIds: [], barcode: "2222222222222" },
        ],
      });
      expect(result.created).toBe(2);
    });

    it("rejects sync with duplicate barcodes in batch", async () => {
      const ctx = createMockContext({ brandId, userId });
      await expect(
        productVariantsRouter.createCaller(ctx).sync({
          productHandle: "test-product",
          variants: [
            { attributeValueIds: [], barcode: "1111111111111" },
            { attributeValueIds: [], barcode: "1111111111111" }, // Duplicate
          ],
        })
      ).rejects.toThrow("already in use");
    });

    it("rejects sync with barcode matching existing variant", async () => {
      const ctx = createMockContext({ brandId, userId });
      await expect(
        productVariantsRouter.createCaller(ctx).sync({
          productHandle: "test-product",
          variants: [
            { attributeValueIds: [], barcode: "1234567890123" }, // Existing
          ],
        })
      ).rejects.toThrow("already in use");
    });

    it("allows sync with mix of barcodes and no-barcodes", async () => {
      const ctx = createMockContext({ brandId, userId });
      const result = await productVariantsRouter.createCaller(ctx).sync({
        productHandle: "test-product",
        variants: [
          { attributeValueIds: [], barcode: "3333333333333" },
          { attributeValueIds: [] }, // No barcode
          { attributeValueIds: [], barcode: undefined },
        ],
      });
      expect(result.created).toBe(3);
    });
  });
});
```

### 9.7 Integration Tests: Database Constraint

**File**: `packages/db/__tests__/integration/queries/barcode-constraint.test.ts`

```typescript
describe("barcode uniqueness constraint", () => {
  // ... setup ...

  it("prevents inserting duplicate barcode in same brand at DB level", async () => {
    // First insert succeeds
    await testDb.insert(productVariants).values({
      productId,
      barcode: "6666666666666",
      upid: generateUpid(),
    });

    // Second insert with same barcode should fail
    await expect(
      testDb.insert(productVariants).values({
        productId,
        barcode: "6666666666666", // Duplicate
        upid: generateUpid(),
      })
    ).rejects.toThrow(/unique constraint|duplicate/i);
  });

  it("allows same barcode in different brands at DB level", async () => {
    const otherBrand = await createTestBrand("Other Brand");
    const otherProduct = await createTestProduct(otherBrand.id);

    // First brand
    await testDb.insert(productVariants).values({
      productId,
      barcode: "4444444444444",
      upid: generateUpid(),
    });

    // Same barcode in different brand should succeed
    await expect(
      testDb.insert(productVariants).values({
        productId: otherProduct.id,
        barcode: "4444444444444",
        upid: generateUpid(),
      })
    ).resolves.toBeDefined();
  });

  it("allows multiple null barcodes in same brand", async () => {
    await testDb.insert(productVariants).values({
      productId,
      barcode: null,
      upid: generateUpid(),
    });

    await expect(
      testDb.insert(productVariants).values({
        productId,
        barcode: null,
        upid: generateUpid(),
      })
    ).resolves.toBeDefined();
  });

  it("allows multiple empty string barcodes in same brand", async () => {
    await testDb.insert(productVariants).values({
      productId,
      barcode: "",
      upid: generateUpid(),
    });

    await expect(
      testDb.insert(productVariants).values({
        productId,
        barcode: "",
        upid: generateUpid(),
      })
    ).resolves.toBeDefined();
  });
});
```

### 9.8 Integration Tests: Quick Filter

**File**: `apps/api/__tests__/integration/trpc/barcode-filter.test.ts`

```typescript
describe("products.list with barcodeComplete filter", () => {
  // Setup products with varying barcode coverage
  beforeEach(async () => {
    // Product 1: All variants have barcodes (complete)
    const product1 = await createTestProduct(brandId, { name: "Complete" });
    await createTestVariant(product1, { barcode: "1111111111111" });
    await createTestVariant(product1, { barcode: "2222222222222" });

    // Product 2: Some variants have barcodes (incomplete)
    const product2 = await createTestProduct(brandId, { name: "Incomplete" });
    await createTestVariant(product2, { barcode: "3333333333333" });
    await createTestVariant(product2, { barcode: null });

    // Product 3: No variants have barcodes (none)
    const product3 = await createTestProduct(brandId, { name: "None" });
    await createTestVariant(product3, { barcode: null });
    await createTestVariant(product3, { barcode: "" });
  });

  it("filters products with complete barcode coverage", async () => {
    const ctx = createMockContext({ brandId, userId });
    const result = await productsRouter.createCaller(ctx).list({
      filters: {
        groups: [{
          id: "g1",
          conditions: [{
            id: "c1",
            fieldId: "barcodeComplete",
            operator: "is any of",
            value: ["complete"],
          }],
          source: "quick",
        }],
      },
    });
    expect(result.data).toHaveLength(1);
    expect(result.data[0].name).toBe("Complete");
  });

  it("filters products with incomplete barcode coverage", async () => {
    const ctx = createMockContext({ brandId, userId });
    const result = await productsRouter.createCaller(ctx).list({
      filters: {
        groups: [{
          id: "g1",
          conditions: [{
            id: "c1",
            fieldId: "barcodeComplete",
            operator: "is any of",
            value: ["incomplete"],
          }],
          source: "quick",
        }],
      },
    });
    expect(result.data).toHaveLength(1);
    expect(result.data[0].name).toBe("Incomplete");
  });

  it("filters products with no barcodes", async () => {
    const ctx = createMockContext({ brandId, userId });
    const result = await productsRouter.createCaller(ctx).list({
      filters: {
        groups: [{
          id: "g1",
          conditions: [{
            id: "c1",
            fieldId: "barcodeComplete",
            operator: "is any of",
            value: ["none"],
          }],
          source: "quick",
        }],
      },
    });
    expect(result.data).toHaveLength(1);
    expect(result.data[0].name).toBe("None");
  });

  it("filters multiple barcode statuses", async () => {
    const ctx = createMockContext({ brandId, userId });
    const result = await productsRouter.createCaller(ctx).list({
      filters: {
        groups: [{
          id: "g1",
          conditions: [{
            id: "c1",
            fieldId: "barcodeComplete",
            operator: "is any of",
            value: ["complete", "incomplete"],
          }],
          source: "quick",
        }],
      },
    });
    expect(result.data).toHaveLength(2);
  });
});
```

### 9.9 Integration Tests: List Response Includes Barcode Count

```typescript
describe("products.list includes variantsWithBarcode", () => {
  it("returns correct barcode count for products", async () => {
    // Create product with mixed barcode coverage
    const product = await createTestProduct(brandId);
    await createTestVariant(product.id, { barcode: "1111111111111" });
    await createTestVariant(product.id, { barcode: "2222222222222" });
    await createTestVariant(product.id, { barcode: null });

    const ctx = createMockContext({ brandId, userId });
    const result = await productsRouter.createCaller(ctx).list({});

    const productRow = result.data.find(p => p.id === product.id);
    expect(productRow.variantCount).toBe(3);
    expect(productRow.variantsWithBarcode).toBe(2);
  });

  it("returns zero for product with no barcodes", async () => {
    const product = await createTestProduct(brandId);
    await createTestVariant(product.id, { barcode: null });
    await createTestVariant(product.id, { barcode: "" });

    const ctx = createMockContext({ brandId, userId });
    const result = await productsRouter.createCaller(ctx).list({});

    const productRow = result.data.find(p => p.id === product.id);
    expect(productRow.variantsWithBarcode).toBe(0);
  });

  it("excludes ghost variants from barcode count", async () => {
    const product = await createTestProduct(brandId);
    await createTestVariant(product.id, { barcode: "1111111111111", isGhost: false });
    await createTestVariant(product.id, { barcode: "2222222222222", isGhost: true }); // Ghost

    const ctx = createMockContext({ brandId, userId });
    const result = await productsRouter.createCaller(ctx).list({});

    const productRow = result.data.find(p => p.id === product.id);
    expect(productRow.variantCount).toBe(1); // Only non-ghost
    expect(productRow.variantsWithBarcode).toBe(1);
  });
});
```

---

## 10. Edge Cases & Error Handling

### 10.1 Race Conditions

**Scenario**: Two users simultaneously try to create variants with the same barcode.

**Handling**: The database unique constraint ensures one insert succeeds and one fails. The API layer catches the constraint violation error and returns a user-friendly message:

```typescript
try {
  await db.insert(productVariants).values({ ... });
} catch (error) {
  if (isUniqueConstraintViolation(error, 'idx_unique_barcode_per_brand')) {
    throw badRequest("This barcode was just claimed by another operation. Please try a different barcode.");
  }
  throw error;
}
```

### 10.2 Existing Duplicate Data

**Scenario**: Migration finds existing duplicate barcodes.

**Handling**: Migration must be run after manual cleanup:
1. Generate report of duplicates
2. Brand owners resolve duplicates manually (via admin UI or direct DB)
3. Migration adds constraint

### 10.3 Empty vs Null Barcodes

Both `""` and `null` are treated as "no barcode" and exempt from uniqueness:
- The unique constraint uses `WHERE barcode IS NOT NULL AND barcode != ''`
- Multiple variants can have empty/null barcodes

### 10.4 Whitespace Handling

Barcodes are trimmed before validation and storage:
- `"  12345678  "` → `"12345678"`
- `"   "` → `null` (treated as empty)

### 10.5 Bulk Import Partial Failures

When bulk import encounters invalid/duplicate barcodes:
1. Log the error for that row
2. Continue processing other rows
3. Store variant without barcode (barcode = null)
4. Include in summary: "X barcodes skipped due to duplicates"

---

## 11. Performance Considerations

### 11.1 Index Usage

The unique index on `(barcode, brand_id)` serves dual purpose:
1. Enforces uniqueness constraint
2. Provides fast lookup for `isBarcodeTakenInBrand`

### 11.2 Query Optimization

The `isBarcodeTakenInBrand` query:
- Uses `LIMIT 1` for early termination
- Joins through product to get brand_id (single query)
- Should execute in <10ms for typical data sizes

### 11.3 Debounced Client Check

The client-side uniqueness check:
- Debounces 500ms to avoid excessive API calls
- Only triggers when format is valid and input is dirty
- Caches results for 10 seconds (staleTime)

---

## 12. Security Considerations

### 12.1 RLS Enforcement

All barcode operations inherit RLS from the product_variants table:
- Users can only check/modify barcodes for their brand's variants
- The `checkBarcode` endpoint is scoped to `brandId` from context

### 12.2 Input Sanitization

- Barcodes are validated against regex before storage
- No SQL injection risk (parameterized queries via Drizzle)
- Max length enforced (100 chars, matching existing schema)

---

## 13. Rollback Plan

If issues arise after deployment:

1. **Disable client-side check**: Remove uniqueness spinner (cosmetic only)
2. **Relax API validation**: Change from throw to warning log
3. **Drop constraint**: `DROP INDEX idx_unique_barcode_per_brand;`

The feature is designed to be incrementally rollable-back without data loss.

---

## 14. Future Considerations

### Not in Scope (Phase 2)

1. **QR Export Integration** - Show barcode coverage warning during export
2. **Bulk Import Preview** - Show barcode validation results before import
3. **Notification System** - Alert users of barcode issues post-import
4. **Check Digit Validation** - Validate GS1 modulo-10 check digit

### Open Questions for Future

1. Should we support non-GS1 barcodes (ISBN, internal SKUs)?
2. Should we auto-pad shorter barcodes to 14 digits for storage?
3. Should we provide barcode generation for brands without existing barcodes?
