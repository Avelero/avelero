/**
 * Product Image Storage Utilities
 *
 * Helper functions for managing product images in Supabase Storage.
 * Ensures consistent path/slug generation between manual and bulk upload flows.
 *
 * Path structure: {brand_id}/products/{product_id}/{image_type}_{timestamp}_{random}.{ext}
 * Example: "uuid/products/uuid/primary_1731772800000_a1b2c3.jpg"
 */

import type { SupabaseClient } from "@supabase/supabase-js";
import { customAlphabet } from "nanoid";
import type { Database } from "../types";

const PRODUCTS_BUCKET = "products" as const;
const MAX_FILE_SIZE_BYTES = 10 * 1024 * 1024; // 10MB per image
const ALLOWED_MIME_TYPES = [
  "image/jpeg",
  "image/jpg",
  "image/png",
  "image/webp",
  "image/avif",
] as const;

const ALLOWED_EXTENSIONS = [".jpg", ".jpeg", ".png", ".webp", ".avif"] as const;

// Generate 8-character random suffix for uniqueness
const nanoid = customAlphabet("0123456789abcdefghijklmnopqrstuvwxyz", 8);

type ImageType = "primary" | "additional" | "variant";

type UploadProductImageParams = {
  file: File;
  brandId: string;
  productId: string;
  imageType: ImageType;
};

type UploadProductImageResult = {
  path: string;
  fullPath: string;
  bucket: string;
  publicUrl?: string;
};

/**
 * Generate a consistent slug for product image storage.
 *
 * Format: {image_type}_{timestamp}_{random}.{ext}
 * Example: "primary_1731772800000_a1b2c3d4.jpg"
 *
 * This ensures:
 * - Consistent naming between manual and bulk uploads
 * - Uniqueness via timestamp + random string
 * - Easy identification of image type
 * - Sortable by upload time
 *
 * @param imageType - Type of image (primary, additional, variant)
 * @param extension - File extension (with dot, e.g., ".jpg")
 * @returns Generated slug
 *
 * @example
 * ```ts
 * const slug = generateProductImageSlug("primary", ".jpg");
 * // Returns: "primary_1731772800000_a1b2c3d4.jpg"
 * ```
 */
export function generateProductImageSlug(
  imageType: ImageType,
  extension: string,
): string {
  const timestamp = Date.now();
  const random = nanoid();
  return `${imageType}_${timestamp}_${random}${extension}`;
}

/**
 * Generate the full storage path for a product image.
 *
 * Path structure: {brand_id}/products/{product_id}/{slug}
 *
 * @param brandId - Brand UUID
 * @param productId - Product UUID
 * @param slug - Image slug (generated by generateProductImageSlug)
 * @returns Full storage path
 *
 * @example
 * ```ts
 * const path = getProductImagePath(
 *   "brand-uuid",
 *   "product-uuid",
 *   "primary_1731772800000_a1b2c3d4.jpg"
 * );
 * // Returns: "brand-uuid/products/product-uuid/primary_1731772800000_a1b2c3d4.jpg"
 * ```
 */
export function getProductImagePath(
  brandId: string,
  productId: string,
  slug: string,
): string {
  return `${brandId}/products/${productId}/${slug}`;
}

/**
 * Upload a product image to Supabase Storage with consistent slug generation.
 *
 * @param client - Supabase client instance
 * @param params - Upload parameters
 * @returns Object containing path, bucket, and public URL
 * @throws Error if validation or upload fails
 *
 * @example
 * ```ts
 * const result = await uploadProductImage(supabase, {
 *   file: imageFile,
 *   brandId: "brand-uuid",
 *   productId: "product-uuid",
 *   imageType: "primary"
 * });
 *
 * // Use result.publicUrl or result.path in database
 * await updateProduct(db, brandId, {
 *   id: productId,
 *   primaryImageUrl: result.publicUrl
 * });
 * ```
 */
export async function uploadProductImage(
  client: Pick<SupabaseClient<Database>, "storage">,
  { file, brandId, productId, imageType }: UploadProductImageParams,
): Promise<UploadProductImageResult> {
  // Validate file size
  if (file.size > MAX_FILE_SIZE_BYTES) {
    throw new Error(
      `Image size exceeds maximum allowed size of ${MAX_FILE_SIZE_BYTES / 1024 / 1024}MB`,
    );
  }

  // Validate MIME type
  if (
    !ALLOWED_MIME_TYPES.includes(
      file.type as (typeof ALLOWED_MIME_TYPES)[number],
    )
  ) {
    throw new Error(
      `Invalid image type: ${file.type}. Allowed types: ${ALLOWED_MIME_TYPES.join(", ")}`,
    );
  }

  // Extract file extension
  const fileExtension = file.name
    .toLowerCase()
    .slice(file.name.lastIndexOf("."));
  if (
    !ALLOWED_EXTENSIONS.includes(
      fileExtension as (typeof ALLOWED_EXTENSIONS)[number],
    )
  ) {
    throw new Error(
      `Invalid file extension: ${fileExtension}. Allowed extensions: ${ALLOWED_EXTENSIONS.join(", ")}`,
    );
  }

  // Generate consistent slug
  const slug = generateProductImageSlug(imageType, fileExtension);

  // Build full path
  const path = getProductImagePath(brandId, productId, slug);

  const storage = client.storage.from(PRODUCTS_BUCKET);

  // Upload with upsert to allow updates
  const result = await storage.upload(path, file, {
    upsert: true,
    cacheControl: "31536000", // 1 year cache for images
    contentType: file.type,
  });

  if (result.error) {
    throw new Error(`Failed to upload product image: ${result.error.message}`);
  }

  // Get public URL (bucket is private, but we can generate signed URLs if needed)
  const { data: urlData } = storage.getPublicUrl(path);

  return {
    path,
    fullPath: result.data.fullPath,
    bucket: PRODUCTS_BUCKET,
    publicUrl: urlData.publicUrl,
  };
}

/**
 * Delete a product image from storage.
 *
 * @param client - Supabase client instance
 * @param brandId - Brand UUID
 * @param productId - Product UUID
 * @param slug - Image slug
 * @throws Error if deletion fails
 *
 * @example
 * ```ts
 * await deleteProductImage(supabase, "brand-uuid", "product-uuid", "primary_1731772800000_a1b2c3d4.jpg");
 * ```
 */
export async function deleteProductImage(
  client: Pick<SupabaseClient<Database>, "storage">,
  brandId: string,
  productId: string,
  slug: string,
): Promise<void> {
  const path = getProductImagePath(brandId, productId, slug);
  const storage = client.storage.from(PRODUCTS_BUCKET);

  const result = await storage.remove([path]);

  if (result.error) {
    throw new Error(`Failed to delete product image: ${result.error.message}`);
  }
}

/**
 * Delete all images for a product.
 *
 * @param client - Supabase client instance
 * @param brandId - Brand UUID
 * @param productId - Product UUID
 * @returns Array of deleted file paths
 * @throws Error if deletion fails
 *
 * @example
 * ```ts
 * const deleted = await deleteProductImages(supabase, "brand-uuid", "product-uuid");
 * console.log(`Deleted ${deleted.length} images`);
 * ```
 */
export async function deleteProductImages(
  client: Pick<SupabaseClient<Database>, "storage">,
  brandId: string,
  productId: string,
): Promise<string[]> {
  const folderPath = `${brandId}/products/${productId}`;
  const storage = client.storage.from(PRODUCTS_BUCKET);

  // List all files in the product folder
  const listResult = await storage.list(folderPath);

  if (listResult.error) {
    throw new Error(
      `Failed to list product images for deletion: ${listResult.error.message}`,
    );
  }

  if (!listResult.data || listResult.data.length === 0) {
    return [];
  }

  // Build full paths
  const filePaths = listResult.data.map((file) => `${folderPath}/${file.name}`);

  // Delete all files
  const deleteResult = await storage.remove(filePaths);

  if (deleteResult.error) {
    throw new Error(
      `Failed to delete product images: ${deleteResult.error.message}`,
    );
  }

  return filePaths;
}

/**
 * Generate a signed URL for temporary product image access.
 *
 * Since the products bucket is private, use this to generate temporary URLs
 * for viewing/downloading images.
 *
 * @param client - Supabase client instance
 * @param brandId - Brand UUID
 * @param productId - Product UUID
 * @param slug - Image slug
 * @param expiresIn - Expiration time in seconds (default: 3600 = 1 hour)
 * @returns Signed URL and expiration timestamp
 * @throws Error if URL generation fails
 *
 * @example
 * ```ts
 * const { signedUrl, expiresAt } = await generateProductImageUrl(
 *   supabase,
 *   "brand-uuid",
 *   "product-uuid",
 *   "primary_1731772800000_a1b2c3d4.jpg"
 * );
 *
 * // Use in image tag
 * <img src={signedUrl} alt="Product" />
 * ```
 */
export async function generateProductImageUrl(
  client: Pick<SupabaseClient<Database>, "storage">,
  brandId: string,
  productId: string,
  slug: string,
  expiresIn = 3600,
): Promise<{ signedUrl: string; expiresAt: Date }> {
  const path = getProductImagePath(brandId, productId, slug);
  const storage = client.storage.from(PRODUCTS_BUCKET);

  const result = await storage.createSignedUrl(path, expiresIn);

  if (result.error) {
    throw new Error(
      `Failed to generate product image URL: ${result.error.message}`,
    );
  }

  const expiresAt = new Date(Date.now() + expiresIn * 1000);

  return {
    signedUrl: result.data.signedUrl,
    expiresAt,
  };
}

/**
 * Validate product image file before upload.
 *
 * @param file - File to validate
 * @returns Validation result with optional error message
 *
 * @example
 * ```ts
 * const validation = validateProductImage(file);
 * if (!validation.valid) {
 *   console.error(validation.error);
 * }
 * ```
 */
export function validateProductImage(file: File): {
  valid: boolean;
  error?: string;
} {
  // Check file size
  if (file.size > MAX_FILE_SIZE_BYTES) {
    return {
      valid: false,
      error: `Image size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds maximum of ${MAX_FILE_SIZE_BYTES / 1024 / 1024}MB`,
    };
  }

  // Check MIME type
  if (
    !ALLOWED_MIME_TYPES.includes(
      file.type as (typeof ALLOWED_MIME_TYPES)[number],
    )
  ) {
    return {
      valid: false,
      error: `Invalid image type: ${file.type}. Allowed: JPEG, PNG, WebP, AVIF`,
    };
  }

  // Check extension
  const fileExtension = file.name
    .toLowerCase()
    .slice(file.name.lastIndexOf("."));
  if (
    !ALLOWED_EXTENSIONS.includes(
      fileExtension as (typeof ALLOWED_EXTENSIONS)[number],
    )
  ) {
    return {
      valid: false,
      error: `Invalid extension: ${fileExtension}. Allowed: .jpg, .png, .webp, .avif`,
    };
  }

  return { valid: true };
}

// Export constants
export const PRODUCT_IMAGE_CONSTANTS = {
  BUCKET: PRODUCTS_BUCKET,
  MAX_FILE_SIZE_BYTES,
  MAX_FILE_SIZE_MB: MAX_FILE_SIZE_BYTES / 1024 / 1024,
  ALLOWED_MIME_TYPES,
  ALLOWED_EXTENSIONS,
} as const;
